浏览器内核
主要分成两个部分：渲染引擎(Render Engine)和JS引擎。
渲染引擎：负责取得网页的内容(html,xml和图像等)，整理讯息(例如假如css)，以及计算网页的显示方式，然后输出到显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不同。所有网页浏览器、电子邮件客户端以及它需要编辑、显示网络内容的应用程序都需要内核。
JS引擎：解析和执行JavaScript来实现网页的动态效果。

IE浏览器内核：Trident内核，也被称为IE内核
Chrome浏览器内核：Chromium内核 → Webkit内核 → Blink内核
Firefox浏览器内核：Gecko内核，也被称Firefox内核
Safari浏览器内核：Webkit内核
Opera浏览器内核：最初是自主研发的Presto内核，后跟随谷歌，从Webkit到Blink内核
360浏览器、猎豹浏览器内核：IE+Chrome双内核
搜狗、遨游、QQ浏览器内核：Trident（兼容模式）+ Webkit（高速模式）
百度浏览器、世界之窗内核：IE内核
2008 年，谷歌公司发布了 chrome 浏览器，浏览器使用的内核被命名为 chromium。chromium fork 自开源引擎 webkit，所以有些地方会把 chromium 引擎和 webkit 区分开来单独介绍，而有的文章把 chromium 归入 webkit 引擎中，都是有一定道理的。
2013 年 4 月 3 日，谷歌在 Chromium Blog 上发表 博客称将与苹果的开源浏览器核心 Webkit 分道扬镳，在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。


浏览器渲染过程
一、进程和线程
进程是CPU进行资源分配的基本单位
线程是CPU调度的最小单位，是建立在进程的基础上运行的单位，共享进程的内存空间。
1、进程是会占用系统资源；2、一个进程内可以存在一个或者多个线程，这就是单线程和多线程；3、无论是单线程还是多线程都是在一个进程内

二、多进程
1、浏览器是多进程   2、不同类型的标签页都会开启一个新的进程  3、相同类型的标签页是会合并到一个进程
浏览器进程
（1）负责管理各个标签页的创建和销毁（2）负责浏览器的页面显示和功能（前进，后退，收藏等）（3）负责资源的管理与下载
第三方插件进程
（1）负责每个第三方插件的使用，每个第三方插件使用时候都会创建一个对应的进程
GPU进程
（1）负责3D绘制和硬件加速
浏览器渲染进程
（1）浏览器内核，主要负责HTML，CSS，JS等文件的解析和执行

三、浏览器内核
浏览器内核就是浏览器渲染进程，从接收下载文件后再到呈现整个页面的过程，由浏览器渲染进程负责，主要流程如下：
1、解析HTML文件和CSS文件，加载图片等资源文件，渲染成用户看到的页面
2、执行解析js文件脚本代码

这里主要讲浏览器页面渲染过程，js脚本解析执行过程，可以看这篇文章：Javascript引擎执行的过程的理解--执行阶段（https://www.mwcxs.top/page/564.html），所以本文的js解析的内容会省略
在该过程中浏览器渲染进程会开启多个线程协作完成，主要的线程以及作用如下：
1、GUI渲染线程
（1）负责解析HTML文件构建DOM树，解析CSS，结合DOM树渲染成RenderObject树，然后布局和绘制页面
（2）当RenderObject树需要更新样式属性时(如背景色)，即发生重绘（Repaint）；当RenderObject树中的元素规则尺寸，布局或显示隐藏等发生变化，即发生回流（reflow）
2、JS引擎线程
3、事件触发线程
4、定时器触发线程
5、异步Http请求线程
注：GUI渲染线程与JS引擎线程是相互排斥的，因为JS引擎线程在执行的过程中可能会发生重绘和回流，所以GUI渲染线程执行时候，JS引擎线程会被挂起，等待GUI渲染线程执行完毕之后，JS引擎线程执行时候同理。
注意：
1、默认图层指的是出于普通文档流的元素（元素按照本身的属性进行的一个页面排版 独占一行 竖着排版 无论大小是什么  <P>   <div>不是独占一行 不能设置大小 横着排版  <span>  <em>  <strong>不是独占一行 可以设置宽高 横着排版   <input>）
2、复合图层一般指的使用动画执行或者<video><iframe><canvas><webgl>等元素，也可以使用z-index将层级高的元素变成复合图层，使用复合图层可以进行硬件加速，其原理是避免了默认图层的重绘和回流，想了解更深入介意自行研究

了解GUI渲染线程的执行过程，我们可以根据原理进行渲染优化：
1、尽可能早的提前引入css文件，例如在头部引入css文件。
2、尽可能早的加载css文件中的引入的资源，例如自定义字体文件，可以使用预加载，在link标签中加入rel=“preload” as = “font”该元素属性，不会造成渲染阻塞。
3、在DOM和CSS渲染之后加载js文件，例如在尾部加载js文件，或者使用该元素属性defer和async，进行js问价异步加载，但是不同的浏览器会有兼容性问题。

js脚本解析执行过程
全面分析js引擎的执行过程，分为三个阶段
一、语法分析
浏览器先按照js的顺序加载<script>标签分隔的代码块，js代码块加载完毕之后，会首先进入到语法分析阶段，该阶段的主要作用：
分析该js脚本代码块的语法是否正确，如果出现不正确会向外抛出一个语法错误（syntaxError），停止改js代码的执行，然后继续查找并加载下一个代码块；如果语法正确，则进入到预编译阶段。
二、预编译阶段
通过语法分析阶段后，进入预编译阶段，则创建变量对象（创建arguments对象（函数运行环境下），函数声明提前解析，变量声明提升），确定作用域链以及this指向。
js运行环境：全局环境  函数环境  eval环境
每进入到一个不同的运行环境都会创建 一个相应的执行上下文（execution context），那么在一段js程序中一般都会创建多个执行上下文，js引擎会以栈的数据结构对这些执行进行处理，形成函数调用栈（call stack），栈底永远是全局执行上下文（global execution context），栈顶则永远时当前的执行上下文。
函数调用栈就是使用栈存取的方式进行管理运行环境，特点是先进后出，后进先出 例一个函数的执行 先创建全局上下文 在局部上下文 读取调用的时候 先 局部上下文搜索 在全局上下文搜索
创建执行上下问的三件事
1、创建变量对象（variable object）
（1）、创建arguments对象，检查当前上下文的参数，建立该对象的属性与属性值，仅在函数环境（非箭头函数）中进行的，全局环境没有此过程。
（2）、检查当前上下文的函数声明，按照代码顺序查找，将找到的函数提前声明，如果当前上下文的变量对象没有该函数名属性，则在该变量对象以函数名建立一个属性，属性值则指向该函数所在堆内存地址引用，如果存在，则会被新的引用覆盖掉。
（3）、检查当前上下文的变量声明，爱去哪找代码顺序查找，将找到的变量提前声明，如果当前上下文的变量对象没有变量名属性，则在该变量对象以变量名建立一个属性，属性值为undefined；如果存在，则忽略该变量声明。
说明：在全局环境中，window对象就是全局执行上下文的变量对象，所有的变量和函数都是window对象的属性方法。
      所以函数声明提前和变量声明提升是在创建变量对象中进行的，且函数声明优先级高于变量声明。
2、创建作用域链（scope chain）
作用域链由当前执行环境的变量对象（未进入到执行阶段前）与上层环境的一系列活动对象组成，保证了当前执行还款对符合访问权限的变量和函数有序访问。
3、确定this的指向
三、执行阶段
1、js是单线程的，为了避免代码解析阻塞使用了异步执行，那么它的异步执行机制是怎么样的？
答：通过事件循环（Event Loop），理解了事件循环的原理就理解了js的异步执行机制，本文主要介绍。
2、js是单线程的，那么是否代表参与js执行过程的线程就只有一个？
答：不是的，会有四个线程参与该过程，但是永远只有JS引擎线程在执行JS脚本程序，其他的三个线程只协助，不参与代码解析与执行。参与js执行过程的线程分别是：
（1）JS引擎线程： 也称为JS内核，负责解析执行Javascript脚本程序的主线程（例如V8引擎）。
（2）事件触发线程： 归属于浏览器内核进程，不受JS引擎线程控制。主要用于控制事件（例如鼠标，键盘等事件），当该事件被触发时候，事件触发线程就会把该事件的处理函数推进事件队列，等待JS引擎线程执行。
（3）定时器触发线程：主要控制计时器setInterval和延时器setTimeout，用于定时器的计时，计时完毕，满足定时器的触发条件，则将定时器的处理函数推进事件队列中，等待JS引擎线程执行。
注：W3C在HTML标准中规定setTimeout低于4ms的时间间隔算为4ms。
（4）HTTP异步请求线程：通过XMLHttpRequest连接后，通过浏览器新开的一个线程，监控readyState状态变更时，如果设置了该状态的回调函数，则将该状态的处理函数推进事件队列中，等待JS引擎线程执行。
注：浏览器对同一域名请求的并发连接数是有限制的，Chrome和Firefox限制数为6个，ie8则为10个。

console.log('script start');

setTimeout(function() {
  console.log('setTimeout');
}, 0);

Promise.resolve().then(function() {
  console.log('promise1');
}).then(function() {
  console.log('promise2');
});

console.log('script end');

宏任务（macro-task），宏任务又按执行顺序分为同步任务和异步任务
（1）同步任务
console.log('script start');
console.log('script end');
（2）异步任务
setTimeout(function() {
  console.log('setTimeout');
}, 0);
2、微任务（micro-task）
Promise.resolve().then(function() {
  console.log('promise1');
}).then(function() {
  console.log('promise2');
});
在JS引擎执行过程中，进入执行阶段后，代码的执行顺序如下：宏任务(同步任务) --> 微任务 --> 宏任务(异步任务)
进入ES6或Node环境中，JS的任务分为两种，分别是宏任务（macro-task）和微任务（micro-task），在最新的ECMAScript中，微任务称为jobs，宏任务称为task，他们的执行顺序如上。
2.1 宏任务
宏任务（macro-task）可分为同步任务和异步任务：
1、同步任务指的是在JS引擎主线程上按顺序执行的任务，只有前一个任务执行完毕后，才能执行后一个任务，形成一个执行栈（函数调用栈）。
2、异步任务指的是不直接进入JS引擎主线程，而是满足触发条件时，相关的线程将该异步任务推进任务队列(task queue)，等待JS引擎主线程上的任务执行完毕，空闲时读取执行的任务，例如异步Ajax，DOM事件，setTimeout等。
理解宏任务中同步任务和异步任务的执行顺序，那么就相当于理解了JS异步执行机制C事件循环（Event Loop）
事件循环可以理解成由三部分组成，分别是：
1、主线程执行栈
2、异步任务等待触发
3、任务队列
任务队列(task queue)就是以队列的数据结构对事件任务进行管理，特点是先进先出，后进后出。

在JS引擎主线程执行过程中：

1、首先执行宏任务的同步任务，在主线程上形成一个执行栈，可理解为函数调用栈。
2、当执行栈中的函数调用到一些异步执行的API（例如异步Ajax，DOM事件，setTimeout等API），则会开启对应的线程（Http异步请求线程，事件触发线程和定时器触发线程）进行监控和控制。
3、当异步任务的事件满足触发条件时，对应的线程则会把该事件的处理函数推进任务队列(task queue)中，等待主线程读取执行。
4、当JS引擎主线程上的任务执行完毕，则会读取任务队列中的事件，将任务队列中的事件任务推进主线程中，按任务队列顺序执行
5、当JS引擎主线程上的任务执行完毕后，则会再次读取任务队列中的事件任务，如此循环，这就是事件循环（Event Loop）的过程。

我们都知道setTimeout和setInterval是异步任务的定时器，需要添加到任务队列等待主线程执行，那么使用setTimeout模拟实现setInterval，会有区别吗？
答案是有区别的，我们不妨思考一下：
1、setTimeout实现setInterval只能通过递归调用。
2、setTimeout是在到了指定时间的时候就把事件推到任务队列中，只有当在任务队列中的setTimeout事件被主线程执行后，才会继续再次在到了指定时间的时候把事件推到任务队列，那么setTimeout的事件执行肯定比指定的时间要久，具体相差多少跟代码执行时间有关。
3、setInterval则是每次都精确的隔一段时间就向任务队列推入一个事件，无论上一个setInterval事件是否已经执行，所以有可能存在setInterval的事件任务累积，导致setInterval的代码重复连续执行多次，影响页面性能。
综合以上的分析，使用setTimeout实现计时功能是比setInterval性能更好的。当然如果不需要兼容低版本的IE浏览器，使用requestAnimationFrame是更好的选择。

我们继续再做进一步的思考，如下：
高频率触发的事件（例如滚动事件）触发频率过高会影响页面性能，甚至造成页面卡顿，我们是否可以利用计时器的原理进行优化呢？
是可以的，我们可以利用setTimeout实现计时器的原理，对高频触发的事件进行优化，实现点在于将多个触发事件合并成一个，这就是防抖和节流

在宏任务中执行的任务有两种，分别是同步任务和异步任务，因为异步任务会在满足触发条件时才会推进任务队列（task queue），然后等待主线程上的任务执行完毕，再读取任务队列中的任务事件，最后推进主线程执行，所以这里将异步任务即任务队列看作是新的宏任务。执行的过程如上图所示：

1、执行宏任务中同步任务，执行结束。

2、检查是否存在可执行的微任务，有的话执行所有微任务，然后读取任务队列的任务事件，推进主线程形成新的宏任务；没有的话则读取任务队列的任务事件，推进主线程形成新的宏任务。

3、执行新宏任务的事件任务，再检查是否存在可执行的微任务，如此不断的重复循环。





































参考 https://segmentfault.com/a/1190000018038146